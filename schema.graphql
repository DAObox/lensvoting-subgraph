# Dao
type Dao @entity {
  id: ID! # use address as id
  subdomain: String
  creator: Bytes!
  metadata: String
  createdAt: BigInt!
  token: ERC721Contract
  actions: [Action!]! @derivedFrom(field: "dao")
  transfers: [TokenTransfer!]! @derivedFrom(field: "dao")
  balances: [TokenBalance!]! @derivedFrom(field: "dao")
  contractPermissionIds: [ContractPermissionId!]! @derivedFrom(field: "dao")
  permissions: [Permission!]! @derivedFrom(field: "dao")
  proposals: [IProposal!]! @derivedFrom(field: "dao")
  trustedForwarder: Bytes
  signatureValidator: Bytes
  standardCallbacks: [StandardCallback!]! @derivedFrom(field: "dao")

  plugins: [IPlugin!]! @derivedFrom(field: "dao") # TODO: Refactor to `PluginInstallation` after the plugins left the Aragon OSx subgraph
}

type Action @entity {
  id: ID!
  to: Bytes!
  value: BigInt!
  data: Bytes!
  dao: Dao!
  proposal: IProposal!
  execResult: Bytes
}

interface IProposal {
  id: ID! # package + proposalId
  dao: Dao!
  creator: Bytes!
  metadata: String
  actions: [Action!]! @derivedFrom(field: "proposal")
  allowFailureMap: BigInt!
  failureMap: BigInt
  executed: Boolean!
  createdAt: BigInt!
  startDate: BigInt!
  endDate: BigInt!
  executionTxHash: Bytes
}

type ERC721Contract implements Token @entity(immutable: true) {
  id: ID! # use address as id
  name: String
  symbol: String
}

interface Token {
  id: ID! # use address as id
  name: String
  symbol: String
}

interface TokenTransfer {
  id: ID!
  dao: Dao!
  from: Bytes!
  to: Bytes!
  type: TransferType!
  proposal: IProposal
  txHash: Bytes!
  createdAt: BigInt!
}

enum TransferType {
  ExternalTransfer # when from/to are both NOT equal to dao.
  Withdraw
  Deposit
}

type ERC721Balance implements TokenBalance @entity {
  id: ID!
  token: ERC721Contract!
  dao: Dao!
  tokenIds: [BigInt!]!
  lastUpdated: BigInt!
}

type ERC20Balance implements TokenBalance @entity {
  id: ID!
  token: ERC20Contract!
  dao: Dao!
  balance: BigInt!
  lastUpdated: BigInt!
}

type NativeBalance implements TokenBalance @entity {
  id: ID!
  dao: Dao!
  balance: BigInt!
  lastUpdated: BigInt!
}

interface TokenBalance {
  id: ID! # dao address + token address
  dao: Dao!
  lastUpdated: BigInt!
}

type ContractPermissionId @entity(immutable: true) {
  id: ID! # where + permissionId
  dao: Dao!
  where: Bytes!
  permissionId: Bytes!
}

# Cannot be immutable because a permission can be revoked and granted in the same TX.
# This results in an error in the subgraph if the entity is immutable.
type Permission @entity {
  "no need to store granted as we can delete permission when revoked"
  id: ID! # where + permissionId + who
  dao: Dao!
  where: Bytes!
  contractPermissionId: ContractPermissionId!
  who: Bytes!
  actor: Bytes!
  condition: Bytes
}

type StandardCallback @entity {
  id: ID!
  dao: Dao!
  interfaceId: Bytes!
  callbackSelector: Bytes!
  magicNumber: Bytes!
}

# Don't implement IPlugin. Otherwise it would show up under plugins in the DAO entity
type PluginInstallation @entity {
  id: ID! # psp installationId
  dao: Dao!
  plugin: IPlugin # The plugin address as id provided by the applied preparation
  appliedPreparation: PluginPreparation
  appliedSetupId: Bytes # The setupId of the application see PSP documentation for more info
  appliedVersion: PluginVersion # Stored to track installations in the different plugin versions
  appliedPluginRepo: PluginRepo # Stored to track installation in the different plugin repos
  preparations: [PluginPreparation!]! @derivedFrom(field: "installation")
  state: PluginPreparationState!
}

interface IPlugin {
  id: ID! # plugin address
  dao: Dao!
  pluginAddress: Bytes!

  installations: [PluginInstallation!]! @derivedFrom(field: "plugin")

  # TODO: Uncomment as soon as the plugins have their own subgraph
  # appliedPreparation: PluginPreparation
  # appliedSetupId: Bytes # The setupId of the application see PSP documentation for more info
  # preparations: [PluginPreparation!]! @derivedFrom(field: "plugin")
  # state: PluginPreparationState!
}
